// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: item_details.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllItemsByListWithDetails = `-- name: GetAllItemsByListWithDetails :many
SELECT
    i.id, i.list_id, i.type_id, i.title, i.content, i.url, i.thumbnail, i.created_at, i.updated_at, i.category, i.tags, i.summary, i.embedding,
    it.name as type_name,
    it.description as type_description
FROM items i
LEFT JOIN item_types it ON i.type_id = it.id
JOIN lists l ON i.list_id = l.id
WHERE l.user_id = $1 AND l.id = $2
ORDER BY i.created_at DESC
`

type GetAllItemsByListWithDetailsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

type GetAllItemsByListWithDetailsRow struct {
	ID              pgtype.UUID      `json:"id"`
	ListID          pgtype.UUID      `json:"list_id"`
	TypeID          pgtype.UUID      `json:"type_id"`
	Title           pgtype.Text      `json:"title"`
	Content         pgtype.Text      `json:"content"`
	Url             pgtype.Text      `json:"url"`
	Thumbnail       pgtype.Text      `json:"thumbnail"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	Category        pgtype.Text      `json:"category"`
	Tags            []string         `json:"tags"`
	Summary         pgtype.Text      `json:"summary"`
	Embedding       []float64        `json:"embedding"`
	TypeName        pgtype.Text      `json:"type_name"`
	TypeDescription pgtype.Text      `json:"type_description"`
}

func (q *Queries) GetAllItemsByListWithDetails(ctx context.Context, arg GetAllItemsByListWithDetailsParams) ([]GetAllItemsByListWithDetailsRow, error) {
	rows, err := q.db.Query(ctx, getAllItemsByListWithDetails, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllItemsByListWithDetailsRow
	for rows.Next() {
		var i GetAllItemsByListWithDetailsRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.TypeID,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.Tags,
			&i.Summary,
			&i.Embedding,
			&i.TypeName,
			&i.TypeDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemWithDetails = `-- name: GetItemWithDetails :one

SELECT
    i.id, i.list_id, i.type_id, i.title, i.content, i.url, i.thumbnail, i.created_at, i.updated_at, i.category, i.tags, i.summary, i.embedding,
    it.name as type_name,
    it.description as type_description
FROM items i
LEFT JOIN item_types it ON i.type_id = it.id
WHERE i.id = $1
`

type GetItemWithDetailsRow struct {
	ID              pgtype.UUID      `json:"id"`
	ListID          pgtype.UUID      `json:"list_id"`
	TypeID          pgtype.UUID      `json:"type_id"`
	Title           pgtype.Text      `json:"title"`
	Content         pgtype.Text      `json:"content"`
	Url             pgtype.Text      `json:"url"`
	Thumbnail       pgtype.Text      `json:"thumbnail"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	Category        pgtype.Text      `json:"category"`
	Tags            []string         `json:"tags"`
	Summary         pgtype.Text      `json:"summary"`
	Embedding       []float64        `json:"embedding"`
	TypeName        pgtype.Text      `json:"type_name"`
	TypeDescription pgtype.Text      `json:"type_description"`
}

// Add these to your queries.sql file
func (q *Queries) GetItemWithDetails(ctx context.Context, id pgtype.UUID) (GetItemWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getItemWithDetails, id)
	var i GetItemWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.ListID,
		&i.TypeID,
		&i.Title,
		&i.Content,
		&i.Url,
		&i.Thumbnail,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Category,
		&i.Tags,
		&i.Summary,
		&i.Embedding,
		&i.TypeName,
		&i.TypeDescription,
	)
	return i, err
}

const getItemsWithTypeByList = `-- name: GetItemsWithTypeByList :many
SELECT
    i.id, i.list_id, i.type_id, i.title, i.content, i.url, i.thumbnail, i.created_at, i.updated_at, i.category, i.tags, i.summary, i.embedding,
    it.id as type_id,
    it.name as type_name,
    it.description as type_description
FROM items i
LEFT JOIN item_types it ON i.type_id = it.id
JOIN lists l ON i.list_id = l.id
WHERE l.user_id = $1 AND l.id = $2
ORDER BY i.created_at DESC
`

type GetItemsWithTypeByListParams struct {
	UserID pgtype.UUID `json:"user_id"`
	ID     pgtype.UUID `json:"id"`
}

type GetItemsWithTypeByListRow struct {
	ID              pgtype.UUID      `json:"id"`
	ListID          pgtype.UUID      `json:"list_id"`
	TypeID          pgtype.UUID      `json:"type_id"`
	Title           pgtype.Text      `json:"title"`
	Content         pgtype.Text      `json:"content"`
	Url             pgtype.Text      `json:"url"`
	Thumbnail       pgtype.Text      `json:"thumbnail"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	UpdatedAt       pgtype.Timestamp `json:"updated_at"`
	Category        pgtype.Text      `json:"category"`
	Tags            []string         `json:"tags"`
	Summary         pgtype.Text      `json:"summary"`
	Embedding       []float64        `json:"embedding"`
	TypeID_2        pgtype.UUID      `json:"type_id_2"`
	TypeName        pgtype.Text      `json:"type_name"`
	TypeDescription pgtype.Text      `json:"type_description"`
}

func (q *Queries) GetItemsWithTypeByList(ctx context.Context, arg GetItemsWithTypeByListParams) ([]GetItemsWithTypeByListRow, error) {
	rows, err := q.db.Query(ctx, getItemsWithTypeByList, arg.UserID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsWithTypeByListRow
	for rows.Next() {
		var i GetItemsWithTypeByListRow
		if err := rows.Scan(
			&i.ID,
			&i.ListID,
			&i.TypeID,
			&i.Title,
			&i.Content,
			&i.Url,
			&i.Thumbnail,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Category,
			&i.Tags,
			&i.Summary,
			&i.Embedding,
			&i.TypeID_2,
			&i.TypeName,
			&i.TypeDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTagsByItems = `-- name: GetTagsByItems :many
SELECT
    it.item_id,
    t.id as tag_id,
    t.name as tag_name
FROM item_tags it
JOIN tags t ON it.tag_id = t.id
WHERE it.item_id = ANY($1::uuid[])
`

type GetTagsByItemsRow struct {
	ItemID  pgtype.UUID `json:"item_id"`
	TagID   pgtype.UUID `json:"tag_id"`
	TagName string      `json:"tag_name"`
}

func (q *Queries) GetTagsByItems(ctx context.Context, dollar_1 []pgtype.UUID) ([]GetTagsByItemsRow, error) {
	rows, err := q.db.Query(ctx, getTagsByItems, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTagsByItemsRow
	for rows.Next() {
		var i GetTagsByItemsRow
		if err := rows.Scan(&i.ItemID, &i.TagID, &i.TagName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
